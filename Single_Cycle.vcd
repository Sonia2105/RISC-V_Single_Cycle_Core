$date
	Sat Aug 16 23:15:33 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Single_Cycle_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module Single_Cycle_top $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 # ResultSrc $end
$var wire 1 $ RegWrite $end
$var wire 32 % ReadData [31:0] $end
$var wire 32 & RD_Instr [31:0] $end
$var wire 32 ' RD2_Top [31:0] $end
$var wire 32 ( RD1_Top [31:0] $end
$var wire 32 ) PC_Top [31:0] $end
$var wire 32 * PCPlus4 [31:0] $end
$var wire 1 + MemWrite $end
$var wire 32 , Imm_Ext_Top [31:0] $end
$var wire 2 - ImmSrc [1:0] $end
$var wire 1 . ALUSrc $end
$var wire 32 / ALUResult [31:0] $end
$var wire 3 0 ALUControl_Top [2:0] $end
$scope module ALU_inst $end
$var wire 1 1 Carry $end
$var wire 1 2 OverFlow $end
$var wire 1 3 Zero $end
$var wire 32 4 Sum [31:0] $end
$var wire 32 5 Result [31:0] $end
$var wire 1 6 Negative $end
$var wire 1 7 Cout $end
$var wire 32 8 B [31:0] $end
$var wire 3 9 ALUControl [2:0] $end
$var wire 32 : A [31:0] $end
$upscope $end
$scope module CU_inst $end
$var wire 7 ; Op [6:0] $end
$var wire 3 < funct3 [2:0] $end
$var wire 7 = funct7 [6:0] $end
$var wire 1 # ResultSrc $end
$var wire 1 $ RegWrite $end
$var wire 1 + MemWrite $end
$var wire 2 > ImmSrc [1:0] $end
$var wire 1 ? Branch $end
$var wire 1 . ALUSrc $end
$var wire 2 @ ALUOp [1:0] $end
$var wire 3 A ALUControl [2:0] $end
$scope module AD $end
$var wire 3 B Funct3 [2:0] $end
$var wire 7 C Funct7 [6:0] $end
$var wire 7 D Op [6:0] $end
$var wire 2 E ALUOp [1:0] $end
$var reg 3 F ALUControl [2:0] $end
$upscope $end
$scope module MD $end
$var wire 7 G Op [6:0] $end
$var wire 1 # ResultSrc $end
$var wire 1 $ RegWrite $end
$var wire 1 + MemWrite $end
$var wire 2 H ImmSrc [1:0] $end
$var wire 1 ? Branch $end
$var wire 1 . ALUSrc $end
$var wire 2 I ALUOp [1:0] $end
$upscope $end
$upscope $end
$scope module DM_inst $end
$var wire 32 J A [31:0] $end
$var wire 1 + WE $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 K WD [31:0] $end
$var wire 32 L RD [31:0] $end
$upscope $end
$scope module InstrMem_inst $end
$var wire 1 " rst $end
$var wire 32 M RD [31:0] $end
$var wire 32 N A [31:0] $end
$upscope $end
$scope module PCAdder_inst $end
$var wire 32 O b [31:0] $end
$var wire 32 P c [31:0] $end
$var wire 32 Q a [31:0] $end
$upscope $end
$scope module PC_inst $end
$var wire 32 R PC_Next [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var reg 32 S PC [31:0] $end
$upscope $end
$scope module RegFile_inst $end
$var wire 5 T A1 [4:0] $end
$var wire 5 U A2 [4:0] $end
$var wire 5 V A3 [4:0] $end
$var wire 32 W WD3 [31:0] $end
$var wire 1 $ WE3 $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var reg 32 X RD1 [31:0] $end
$var reg 32 Y RD2 [31:0] $end
$upscope $end
$scope module SignExt_inst $end
$var wire 32 Z In [31:0] $end
$var wire 32 [ Imm_Ext [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
bx S
bx R
bx Q
bx P
b100 O
bx N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
0?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
07
06
b0 5
b0 4
13
02
01
b0 0
b0 /
0.
b0 -
b0 ,
0+
bx *
bx )
b0 (
b0 '
b0 &
b0 %
0$
0#
0"
0!
$end
#50
b100 *
b100 P
b100 R
b0 )
b0 N
b0 Q
b0 S
1!
#100
03
b11100 /
b11100 5
b11100 J
11
b11100 4
17
1$
1.
b11111111111111111111111111111100 ,
b11111111111111111111111111111100 8
b11111111111111111111111111111100 [
1#
bx '
bx K
bx Y
b100000 (
b100000 :
b100000 X
b11 =
b11 C
b10 <
b10 B
b11 ;
b11 D
b11 G
b110 V
b11100 U
b1001 T
b100000 %
b100000 L
b100000 W
b11111111110001001010001100000011 &
b11111111110001001010001100000011 M
b11111111110001001010001100000011 Z
1"
0!
#150
x2
x6
bx %
bx L
bx W
x3
bx /
bx 5
bx J
x1
bx 4
x7
x$
x.
bx ,
bx 8
bx [
bx -
bx >
bx H
x+
x#
x?
bx @
bx E
bx I
bx (
bx :
bx X
bx =
bx C
bx <
bx B
bx ;
bx D
bx G
bx V
bx U
bx T
bx &
bx M
bx Z
b1000 *
b1000 P
b1000 R
b100 )
b100 N
b100 Q
b100 S
1!
#200
0!
#250
b1100 *
b1100 P
b1100 R
b1000 )
b1000 N
b1000 Q
b1000 S
1!
#300
0!
#350
b10000 *
b10000 P
b10000 R
b1100 )
b1100 N
b1100 Q
b1100 S
1!
#400
0!
